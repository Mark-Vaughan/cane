\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{import}
\usepackage{graphicx}
\usepackage{color}
\usepackage[]{algorithm2e}

\setlength{\parindent}{0cm}

% Define own macros
\newcommand{\myfrac}[2]{%
    \ifinner#1/#2%
    \else\frac{#1}{#2}%
    \fi%
}

\title{Signorini frictionless contact problem}

\author{Dr.-Ing. Andreas Apostolatos}

\date{\today}

\begin{document}

\maketitle

\section{Theory}\label{sec:variational_formulation}

\subsection{Linear elasticity}\label{subsec:linear_elasticity}

Given is a deformable body which is geometrically described by $\Omega \subset \mathbb{R}^d$ where $d = 2,3$ stands for the number of the problem's spatial dimensions. Its deformation due to the applied boundary conditions can be uniquely defined by a displacement field $\mathbf{u} = u_i \, \mathbf{e}_i$, $\mathbf{e}_i$ being the Cartesian basis, which maps each each material point of the reference configuration $\mathbf{X} \in \Omega$ to a material point in the current configuration $\mathbf{x} \in \Omega_t$, that is, $\mathbf{x} = \mathbf{X} + \mathbf{u}$. The Einstein's summation convention over the repeated indices is assumed in the sequel if not otherwise mentioned.\\

The strain is described by means of the \textit{Green-Lagrange} (GL) strain second order tensor $\boldsymbol{\mathcal{E}} \in \mathfrak{S}^2$ given by,

\begin{subequations}
	\begin{alignat}{1}
		\boldsymbol{\mathcal{E}} &= \frac{1}{2} \left( \boldsymbol{\nabla} \mathbf{u} + \left( \boldsymbol{\nabla} \mathbf{u} \right)^{\text{t}} +  \boldsymbol{\nabla} \mathbf{u} \cdot \left( \boldsymbol{\nabla} \mathbf{u} \right)^{\text{t}} \right) \;, \label{eq:GL_strain_tensor} \\
		\mathcal{E}_{ij} &= \frac{1}{2} \left( \frac{\partial u_i}{\partial X_j} + \frac{\partial u_j}{\partial X_i} + \frac{\partial u_i}{\partial X_k} \frac{\partial u_k}{\partial X_j} \right) \, \mathbf{e}_k \otimes \mathbf{e}_l \;, \label{eq:GL_strain_comp}
	\end{alignat}
	\label{eq:GL_strain}
\end{subequations}

Assumed is also a Saint-Venant material model which is governed by the material fourth order tensor $\boldsymbol{\mathcal{C}} \in \mathfrak{S}^2$

\begin{equation}
	\boldsymbol{\mathcal{C}} = \frac{E}{2 (1 + \nu)} \left( \delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk} + \frac{2 \nu}{1 - 2 \nu} \delta_{ij} \delta_{kl} \right) \, \mathbf{e}_i \otimes \mathbf{e}_j \otimes \mathbf{e}_k \otimes \mathbf{e}_l \;, \label{eq:material_tensor}
\end{equation}

where $E$ and $\nu$ stand for the Young's modulus and Poisson ratio of the material, respectively. The stress state of the problem is described by means of the 2nd \textit{Piola-Kirchhoff} (PK2) second order ternsor $\boldsymbol{\mathcal{S}} \in \mathfrak{S}^2$ which is given by the linear elastic isotropic law as,

\begin{equation}
	\boldsymbol{\mathcal{S}} = \boldsymbol{\mathcal{C}}  : \boldsymbol{\mathcal{E}} \:.
\end{equation}

\begin{figure}[!t]
	\centering
	\footnotesize
    \def\svgwidth{0.5\textwidth}\import{./figures/}{problem_placement.pdf_tex}
	\caption{Theory: Signorini frictionless contact problem with boundary conditions.}
	\label{im:signorini_contact_problem}
\end{figure}

Given the Dirichlet boundary conditions along $\Gamma_{\text{d}}$ where the displacement is prescribed to a value $\bar{\mathbf{u}}$ (assumed herein zero without loss of generality), the Neumann boundary conditions along $\Gamma_{\text{n}}$ where external tractions $\bar{\mathbf{t}}$ are applied and applied body forces $\mathbf{b}$ in $\Omega$ (e.g. gravitational forces), see Fig.~\ref{im:signorini_contact_problem}, the strong form of the elasticity problem writes,

\begin{subequations}
	\begin{alignat}{2}
		\boldsymbol{\nabla} \cdot \boldsymbol{\mathcal{S}} + \mathbf{b} &= \mathbf{0} \quad &&\text{in } \Omega \;, \label{eq:strong_equilibrium} \\
		\mathbf{u} &= \bar{\mathbf{u}} &&\text{on } \Gamma_{\text{d}} \;, \label{eq:prescribed_displacement} \\
		\boldsymbol{\mathcal{S}} \cdot \mathbf{n} &= \bar{\mathbf{t}} &&\text{on } \Gamma_{\text{n}} \;,
	\end{alignat}
	\label{eq:strong_formulation}
\end{subequations}

where $\mathbf{n}$ stands for the unit outward normal vector to Neumann boundary $\Gamma_{\text{n}}$.

\subsection{Contact conditions}\label{subsec:contact_conditions}

Assumed is also that there is a boundary $\Gamma_{\text{c}} = \Gamma_{\text{c}} (\mathbf{u})$ along which body $\Omega$ is expected to come into contact with a rigid body $\mathfrak{F}$ along a portion of its surface $\mathbb{S} \subset \partial \mathfrak{F}$ which is assumed to be piecewise linear. Assumed is that for each material particle $\mathbf{X} \in \Gamma_{\text{c}}$ there exists a unique material particle $\mathbf{Z} \in \mathbb{S}$ which is closest to $\mathbf{X}$ in Euclidean sense,

\begin{equation}
	\mathbf{Z} = \arg \min_{\bar{\mathbf{Z}} \in \mathbb{S}} \left\| \mathbf{X} - \bar{\mathbf{Z}} \right\|_2 \;. \label{eq:euclidean_distance}
\end{equation}

The so-called gap function is then defined along $\Gamma_{\text{c}}$, namely $g:\Gamma_{\text{c}} \rightarrow \mathbb{R}$ and measures the normal distance between the deformed elastic body $\Omega_t$ and the rigid body $\mathfrak{F}$ along $\Gamma_{\text{c}}$ and $\mathbb{S}$, respectively, that is

\begin{equation}
	g = g_0 - u_n \quad \text{for all }\mathbf{X} \in \Gamma_{\text{c}} \:, \label{eq:gap_function}
\end{equation}

where $u_n = \mathbf{u} \cdot\mathbf{n}$ is the normal component of the displacement field given the outward normal $\mathbf{n}$ to $\Gamma_{\text{c}}$ at $\mathbf{X} \in \Gamma_{\text{c}}$ and $g_0$ is the initial gap given by,

\begin{equation}
	g_0 = \left( \mathbf{X} - \mathbf{Z} \right) \cdot \mathbf{n} \quad \text{for all }\mathbf{X} \in \Gamma_{\text{c}} \;. \label{eq:initial_gap}
\end{equation}

For small gaps it can be assumed that the neither $\mathbf{Z}$ nor the outward normal $\mathbf{k}$ of $\mathbb{S}$ at $\mathbf{Z}$ depend on the displacement field $\mathbf{u}$ but solely on $\mathbf{X} \in \Gamma_{\text{c}}$. Therefore, the following relation can be deduced,

\begin{equation}
	\mathbf{n} = - \mathbf{k} \;. \label{eq:outward_normals}
\end{equation}

The latter assumption comes handy for piecewise linear approximations of the elastic body for which a unit normal vector $\mathbf{n}$ can not be uniquely defined at the nodes. Moreover, the following conditions are also assumed for a frictionless contact,

\begin{itemize}

	\item[1.] no material particle can penetrate the body $\mathfrak{F}$, hence $g \le 0$ for all $\mathbf{X} \in \Gamma_{\text{c}}$,
	
	\item[2.] surface $\mathbb{S}$ is sufficiently lubricated such that no shear tractions develop, that is, $t_t = \mathbf{n} \cdot \boldsymbol{\mathcal{S}} \cdot \mathbf{t} = 0$ where $\mathbf{t}$ stands for the tangent unit vector to $\mathbb{S}$,
	
	\item[3.] the normal tractions along $\Gamma_{\text{c}}$ are compressive, that is, $t_n = \mathbf{n} \cdot \boldsymbol{\mathcal{S}} \cdot \mathbf{n} \ge 0$,
	
	\item[4.] $g = 0$ and $t_n \ge 0$ in case of contact along $\Gamma_{\text{c}}$ whereas $g \le 0$ and $t_n = 0$ otherwise.

\end{itemize}

In this way, the so-called complementarity conditions can be stated as follows,

\begin{subequations}
	\begin{alignat}{1}
		g &\le 0 \;, \label{eq:complementarity_cnd_gap} \\
		t_n &\ge 0 \;,  \label{eq:complementarity_cnd_traction} \\
		t_n\,g &= 0 \:. \label{eq:complementarity_cnd_mixed} 
	\end{alignat}
	\label{eq:complementarity_cnds}
\end{subequations}

Condition in Eq.~\eqref{eq:complementarity_cnd_gap} stands for the non-penetration condition whereas condition in Eq.~\eqref{eq:complementarity_cnd_traction} states that the stresses along the contact boundary need to be compressive. Eq.~\eqref{eq:complementarity_cnd_mixed} is a direct consequence of condition iv.

\subsection{Variational formulation}\label{subsec:variational_formulation}

The weak formulation of the problem in Eq.~\eqref{eq:strong_formulation} subject to the complementarity conditions in Eq.~\eqref{eq:complementarity_cnds} can be written by means of the Langrange Multipliers method: Find $\mathbf{u} \in \boldsymbol{\mathcal{H}}^1 (\Omega)$ with $\mathbf{u} = \mathbf{g}$ on $\Gamma_{\text{d}}$ and $\lambda \in \mathcal{L}^2(\Gamma_{\text{c}})$ with $\lambda \ge 0$ such that,

\begin{subequations}
	\begin{alignat}{1}
		\int_{\Omega} \delta \boldsymbol{\mathcal{E}} : \boldsymbol{\mathcal{S}} \: \text{d} \Omega + \int_{\Gamma_{\text{c}}} \delta u_n \, \lambda \: \text{d} \Gamma &= \int_{\Omega} \delta \mathbf{u} \cdot \mathbf{b} \: \text{d} \Omega + \int_{\Gamma_{\text{n}}} \bar{\mathbf{t}} \cdot \mathbf{u} \: \text{d} \Gamma \label{eq:variational_formulation_delta_u} \\
		\int_{\Gamma_{\text{c}}} \delta \lambda \, u_n \: \text{d} \Gamma &= \int_{\Gamma_{\text{c}}} \delta \lambda \, g_0 \: \text{d} \Gamma \;, \label{eq:variational_formulation_delta_lambda}
	\end{alignat}
	\label{eq:variational_problem_signorini}
\end{subequations}

for all $\delta \mathbf{u} \in \boldsymbol{\mathcal{H}}^1 (\Omega)$ and for all $\delta \lambda \in \mathcal{L}^2(\Gamma_{\text{c}})$ with $\delta \lambda \ge 0$. In fact, $\lambda$ in this case represents the normal traction along the contact boundary $\Gamma_{\text{c}}$ and therefore it must be positive, see Eq.~\eqref{eq:complementarity_cnd_traction}. Eq.~\eqref{eq:variational_formulation_delta_u} is nothing else but the internal virtual work in $\Omega$, whereas Eq.~\eqref{eq:variational_formulation_delta_lambda} accounts for the variation of complementarity condition in Eq.~\eqref{eq:complementarity_cnd_mixed} and renders the problem symmetric as it is also demonstrated in its discrete form.\\

Important is to note that the variational problem in Eq.~\eqref{eq:variational_problem_signorini} is valid only when $\Gamma_{\text{c}} \neq \emptyset$. The latter means that there has to be a non-empty set $\Gamma_{\text{c}}$ along which the complementarity conditions in Eq.~\eqref{eq:complementarity_cnds} are valid. Otherwise, in case that $\Gamma_{\text{c}} = \emptyset$ variational problem in Eq.~\eqref{eq:variational_problem_signorini} reduces to: Find $\mathbf{u} \in \boldsymbol{\mathcal{H}}^1 (\Omega)$ with $\mathbf{u} = \mathbf{g}$ on $\Gamma_{\text{d}}$ such that,

\begin{equation}
	\int_{\Omega} \delta \boldsymbol{\mathcal{E}} : \boldsymbol{\mathcal{S}} \: \text{d} \Omega = \int_{\Omega} \delta \mathbf{u} \cdot \mathbf{b} \: \text{d} \Omega + \int_{\Gamma_{\text{n}}} \bar{\mathbf{t}} \cdot \mathbf{u} \: \text{d} \Gamma \quad \text{for all } \delta \mathbf{u} \in \boldsymbol{\mathcal{H}}^1 (\Omega) \;. \label{eq:variational_formulation_structural_mechanics} \\
\end{equation} 

\section{Discretization}

Assumed is that the displacement field is discretized with the standard linear \textit{Finite Element Method} (FEM) on triangles or quadrilaterals. Employing the Buvnon-Galerkin FEM then the unknown displacement field $\mathbf{u}$ and its variation $\delta \mathbf{u}$ are discretized using the same basis functions $\boldsymbol{\varphi}_i$, that is,

\begin{subequations}
	\begin{alignat}{1}
		\mathbf{u}_h &= \sum_{i = 1}^{n} \boldsymbol{\varphi}_i \hat{u}_i \;, \label{eq:discretization_u} \\
		\delta \mathbf{u}_h &= \sum_{i = 1}^n \boldsymbol{\varphi}_i \delta\hat{u}_i \;, \label{eq:discretization_delta_u}
	\end{alignat}
\end{subequations}

where the linear/bilinear basis functions $\boldsymbol{\varphi}_i$ are constructed as a dual product of the linear/bilinear shape functions $N_i$ at the element's parametric space and the Cartesian basis $\mathbf{e}_i$. Accordingly, $\hat{u}_i$ and $\delta\hat{u}_i$ stand for the \textit{Degrees of Freedom} (DOFs) of the unknown and the test fields, respectively, and $n \in \mathbb{N}$ is the number of nodes in the mesh. Subscript $h$ indicates then the smallest element length size within the employed mesh.\\

Within the node-based contact method, the shape functions for the discretization of the Lagrange Multipliers fields $\lambda$ and $\delta \lambda$ are chosen the diract delta distributions supported on the contact nodes $\mathbf{X}_i$, $i = 1,\ldots,n_{\text{c}}$, that is,

\begin{subequations}
	\begin{alignat}{1}
		\lambda_h &= \sum_{i = 1}^{n_{\text{c}}} \delta(\mathbf{X}_i) \, \hat{\lambda}_i \;, \label{eq:discretization_lambda} \\
		\delta \lambda_h &= \sum_{i = 1}^{n_{\text{c}}} \delta(\mathbf{X}_i) \, \delta\hat{\lambda}_i \;, \label{eq:discretization_lambda_u}
	\end{alignat}
\end{subequations}

where as before $\hat{\lambda}_i$ and $\delta\hat{\lambda}_i$ stand for the Lagrange Multipliers DOFs of the unknown and test fields, respectively. Note that altough there are two DOFs per node for the displacement field, there is only one DOF per node for the Lagrange Multipliers field. This is because the displacement field is a vector field in the $\mathbb{R}^2$ space in two-dimensional elasticity whereas the Lagrange Multipliers field is a scalar field due to the complementarity constraint in Eq.~\eqref{eq:complementarity_cnd_mixed} which is a scalar-valued constraint. In case of a vector-valued constraint, then the Lagrange Multipliers field would also be a vector field.\\

\begin{figure}[!t]
	\centering
	\footnotesize
    \def\svgwidth{0.7\textwidth}\import{./figures/}{finite_element_mesh.pdf_tex}
	\caption{Discretization: Finite element mesh and degrees of freedom.}
	\label{im:finite_element_mesh}
\end{figure}

Substituting the latter expressions in Eq.~\eqref{eq:variational_problem_signorini} the following discrete system of equations is obtained in terms of a Newton-Raphson formulation,

\begin{equation}
	\left[ \begin{array}{cc}
		\mathbf{K} ( \hat{\mathbf{u}}_{\hat{i}} , \hat{\boldsymbol{\lambda}}_{\hat{i}} ) & \mathbf{C}^{\text{t}} \\
		\mathbf{C} & \mathbf{0}
\end{array}	 \right] \, \Delta_{\hat{i}} \, \left[ \begin{array}{c}
	\hat{\mathbf{u}} \\
	\hat{\boldsymbol{\lambda}}
\end{array} \right] = - \left[ \begin{array}{c}
	\mathbf{R} ( \hat{\mathbf{u}}_{\hat{i}} , \hat{\boldsymbol{\lambda}}_{\hat{i}} ) \\
	\boldsymbol{\mathcal{R}} ( \hat{\mathbf{u}}_{\hat{i}} )
\end{array} \right] \;, \label{eq:system_discrete_form_lagrange_multipliers}
\end{equation}

over the so-called active set of Lagrange Multipliers DOFs. The $i$-th component of the residual vector $\mathbf{R}$ derived from Eq.~\eqref{eq:variational_formulation_delta_u} is defined as follows,

\begin{equation}
	\begin{split}
	R_i ( \hat{\mathbf{u}}_{\hat{i}} , \hat{\boldsymbol{\lambda}}_{\hat{i}} ) = \int_{\Omega} \frac{\partial \boldsymbol{\mathcal{E}}}{\partial \hat{u}_i} : \boldsymbol{\mathcal{S}} \: \text{d} \Omega + \sum_{i = 1}^{2 n_{\text{c}}} \sum_{j = 1}^{n_{\text{c}}} \, \boldsymbol{\varphi}_i (\mathbf{X}_j) \cdot \mathbf{n}(\mathbf{X}_j) \, \hat{\lambda}_j - \int_{\Omega} \boldsymbol{\varphi}_i \cdot \mathbf{b} \: \text{d} \Omega \\
	- \int_{\Omega} \boldsymbol{\varphi}_i \cdot \bar{\mathbf{t}} \: \text{d} \Gamma \;.
	\end{split} 
	\label{eq:residual_form_domain}
\end{equation}

The second term in Eq.~\eqref{eq:residual_form_domain} is derived by inserting Eq.~\eqref{eq:discretization_lambda} in Eq.~\eqref{eq:variational_formulation_delta_u} and by using the well-known identity of the Dirac delta distribution, that is,

\begin{equation}
	\begin{split}
	\int_{\Gamma_{\text{c}}} \delta u_n \, \lambda \: \text{d} \Gamma \approx \int_{\Gamma_{\text{c}}} \delta \mathbf{u}_h \cdot \mathbf{n} \, \lambda_h \: \text{d} \Gamma = \sum_{i = 1}^{2 n_{\text{c}}} \sum_{j = 1}^{n_{\text{c}}} \delta \hat{u}_i \int_{\Gamma_{\text{c}}} \boldsymbol{\varphi}_i \cdot \mathbf{n} \; \delta (\mathbf{X}_j) \hat{\lambda}_j  \, \text{d} \Gamma = \\
	\sum_{i = 1}^{2 n_{\text{c}}} \sum_{j = 1}^{n_{\text{c}}} \delta \hat{u}_i \, \boldsymbol{\varphi}_i (\mathbf{X}_j) \cdot \mathbf{n}(\mathbf{X}_j) \, \hat{\lambda}_j \;,
	\end{split} 
	\label{eq:discretization_complementarity}
\end{equation}

where $\boldsymbol{\varphi}_i (\mathbf{X}_j) \cdot \mathbf{n}(\mathbf{X}_j)$ is nothing else but the $\text{mod}\left( (i + 1)/2 \right) + 1$-Cartesian component of the unit normal vector at node $\mathbf{X}_j$ provided that $\lceil i/2 \rceil = j$. The $i$-th component of the residual vector $\boldsymbol{\mathcal{R}}$ derived from Eq.~\eqref{eq:variational_formulation_delta_lambda} is defined as follows,

\begin{equation}
	\mathcal{R}_i ( \hat{\mathbf{u}}_{\hat{i}} ) = g_0(\mathbf{X}_i) + \sum_{j = 1}^{2 n_{\text{c}}} \hat{u}_j \, \boldsymbol{\varphi}_j (\mathbf{X}_i) \cdot \mathbf{n}(\mathbf{X}_i) \;.
\end{equation}

Then, the tangent stiffness matrix $\mathbf{K}$ has components,

\begin{equation}
	K_{ij} ( \hat{\mathbf{u}}_{\hat{i}} ) = \frac{\partial R_i}{\partial \hat{u}_j} = \int_{\Omega} \frac{\partial \boldsymbol{\mathcal{E}}}{\partial \hat{u}_i} : \frac{\partial \boldsymbol{\mathcal{S}}}{\partial \hat{u}_j} + \frac{\partial^2 \boldsymbol{\mathcal{E}}}{\partial \hat{u}_i \partial \hat{u}_j} : \boldsymbol{\mathcal{S}} \: \text{d} \Omega \:. \label{eq:tangent_stiffness_matrix}
\end{equation}

The Lagrange Multipliers matrix $\mathbf{C}$ is then a quasi-diagonal matrix due to the choice of the discretization for the Lagrange Multipliers field and has entries,

\begin{equation}
	C_{ij} =  \boldsymbol{\varphi}_i (\mathbf{X}_j) \cdot \mathbf{n}(\mathbf{X}_j) \:,	\label{eq:lagrange_multipliers_matrix}
\end{equation}

at each active node $\mathbf{X}_i \in \Gamma_{\text{c}}$. Vectors $\hat{\mathbf{u}}$ and $\hat{\boldsymbol{\lambda}}$ stand for the collection of all the displacement and Lagrange Multipliers DOFs as follows,

\begin{subequations}
	\begin{alignat}{1}
		\hat{\mathbf{u}} &= \left[ \begin{array}{ccc} \hat{u}_1 & \cdots & \hat{u}_n \end{array} \right] \;, \label{eq:vector_of_displacement_dofs} \\
		\boldsymbol{\hat{\boldsymbol{\lambda}}} &= \left[ \begin{array}{ccc} \hat{\lambda}_1 & \cdots & \hat{\lambda}_{n_{\text{c}}} \end{array} \right] \;. \label{eq:vector_of_lagrange_multipliers_dofs}
	\end{alignat}
	\label{eq:vectors_of_dofs}
\end{subequations}

The index $\hat{i}$ on $\hat{\mathbf{u}}$ and $\hat{\boldsymbol{\lambda}}$ indicates the Newton-Raphson iteration and $\Delta_{\hat{i}} (\bullet) = (\bullet)_{\hat{i} + 1} - (\bullet)_{\hat{i}}$.

\section{Realization}

As aforementioned, the actual contact surface $\Gamma_{\text{c}}$ is not known in advance, since it depends on the solution $\mathbf{u}$. Given the variational inequality nature of the problem, an iterative approach is employed. There are two possible procedures currently implemented to solve the problem, illustrated in Algorithm~\ref{alg:contact_algorithm_1} and Algorithm~\ref{alg:contact_algorithm_2}. \\

\begin{algorithm}[ht]

	1. Remove fully constrained nodes and compute the initial gap function in Eq.~\eqref{eq:initial_gap} \; \vspace*{5pt}
	
    2. Compute the tangential stiffness matrix of the structure in Eq.~\eqref{eq:tangent_stiffness_matrix} \;	\vspace*{5pt}
    
    3. Create the expanded system of equations \;	\vspace*{5pt}
    
    4. Solve the system iteratively \;	\vspace*{5pt}

	\While{inactive nodes change $\mathbf{and}$ Lagrange Multipliers are not valid}{
	\vspace*{5pt}
	
	4.1. Find the \textit{inactive nodes} from expanded displacement (Lagrange Multiplier) vector \;	\vspace*{5pt}
	
	4.2. Reduce the system of equations according to the \textit{inactive nodes} \;	\vspace*{5pt}
	
	4.3. Solve the reduced system of equations in Eq.~\eqref{eq:system_discrete_form_lagrange_multipliers} \;	\vspace*{5pt}
	
	4.4. Assemble the expanded displacement (Lagrange Multiplier) vector in Eq.~\eqref{eq:vectors_of_dofs} \; \vspace*{5pt}
	
	4.5. Evaluate convergence conditions \; \vspace*{5pt}
	
	}\vspace*{5pt}
	5. Get the values for displacements and Lagrange Multipliers \; \vspace*{5pt}

	\caption{Contact algorithm 1}
	
	\label{alg:contact_algorithm_1}
\end{algorithm}


\begin{algorithm}[ht]

	1. Remove fully constrained nodes and compute the initial gap function in Eq.~\eqref{eq:initial_gap} \; \vspace*{5pt}
	
    2. Compute the tangential stiffness matrix of the structure in Eq.~\eqref{eq:tangent_stiffness_matrix} \;	\vspace*{5pt}
    
    3. Reduce the system according to given constraints \;	\vspace*{5pt}
    
    4. Solve the system iteratively \;	\vspace*{5pt}

	\While{active nodes change}{
	\vspace*{5pt}
	
	4.1. Build the expanded (complete) displacement vector \;	\vspace*{5pt}
	
	4.2. Detect \textit{active nodes} according to Eq.~\eqref{eq:complementarity_cnd_gap} \;	\vspace*{5pt}
	
	4.3. Rebuild the equation system in Eq.~\eqref{eq:system_discrete_form_lagrange_multipliers} if new \textit{active nodes} are found \;	\vspace*{5pt}
	
	4.4. Relax the system until only valid Lagrange multipliers are computed \; \vspace*{5pt}
	
    	\While{Lagrange Multipliers are not valid}{
    	
    	4.4.1. Compute displacements and Lagrange multipliers \;	\vspace*{5pt}
    	
    	4.4.2. Detect and delete non-valid Lagrange Multipliers according to Eq.~\eqref{eq:complementarity_cnd_traction} and Eq.~\eqref{eq:complementarity_cnd_mixed} \;	\vspace*{5pt}
    	
    	}
	
	}\vspace*{5pt}
	5. Get the values for displacements and Lagrange Multipliers \; \vspace*{5pt}

	\caption{Contact algorithm 2}
	
	\label{alg:contact_algorithm_2}
\end{algorithm}

Both algorithms work in a similar manner. At first we need to compute the initial gap function in Eq.~\eqref{eq:initial_gap} and tangential stiffness matrix of the structure in Eq.~\eqref{eq:tangent_stiffness_matrix}. Now we iteratively solve the system of equations. \\

In Algorithm~\ref{alg:contact_algorithm_1} we first create the complete expanded system of equations considering all possible combinations of contact nodes and rigid boundary. Now we check the displacement vector for nodes that are non-penetrating and have non-valid Lagrange Multipliers to detect the so-called \textit{inactive nodes}. This happens at the same time. By using \textit{inactive nodes} we then reduce the system, re-calculate the displacement vector and repeat the previous step until solution converges. The focus here is on the reduction of the equation system.  \\

Algorithm~\ref{alg:contact_algorithm_2} is a bit more complex. Here we first check the displacement vector for penetrating nodes or \textit{active nodes}. We then build the equation system in Eq.~\eqref{eq:system_discrete_form_lagrange_multipliers} in each iteration step for \textit{active nodes} only. At this point we don't know if all corresponding Lagrange Multipliers will be valid, so another nested loop is needed to compute the displacement vector and continuously check for non-valid Lagrange Multipliers. This loop runs until only valid multipliers remain. Displacement vector is updated and the cycle repeats until solution converges. In contrast to Algorithm~\ref{alg:contact_algorithm_1}, the focus now is on the system expansion. \\

By judging the speed of both algorithms only on the number of processed contact nodes, it is clear that Algorithm~\ref{alg:contact_algorithm_2} would preform faster. This is due to the fact, that here the equation system is build only for currently active nodes while in Algorithm~\ref{alg:contact_algorithm_1} we build the whole system from the start. But in Algorithm~\ref{alg:contact_algorithm_1} the system only has to be build once (at the beginning) and not in each iteration step as in Algorithm~\ref{alg:contact_algorithm_2}. Therefore the actual computation time depends on the implementation details and varies from case to case. \\

Before computing the gap function we can remove fully constrained nodes. Nodes that have both DOFs (x,y) fully constrained do not need to be tested for possible contact with the rigid boundary since they will not move. This is not necessary, but it can reduce the computation time. 


\section{Appendix}

This section focuses on the numerical implementation of the Signorini frictionless contact problem in MATLAB computing environment. All data types and functions used in the script are described fully in detail and reflect the algorithms discussed previously. 

\subsection{Structure description}


\subsubsection{contactSegments} 

Is a struct that contains the information about rigid boundary. It consists out of three fields. Field \textit{.points} is a 2x2xN matrix of coordinates structured as follows,

\begin{equation}
	\left[ \begin{array}{cc}
		x_0 & y_0\\
		x_1 & y_1
    \end{array}	 \right] \;. \label{eq:segments_struct}
\end{equation}

Coordinates $x_0$ and $y_0$ represent the first point $\mathbf{A}$, while coordinates $x_1$ and $y_1$ represent the second point $\mathbf{B}$ of the segment. During the calculation, struct $\textbf{contactSegments}$ is further expanded by the field \textit{.normals} which is a Nx2 matrix. Where N is the number of segments defined in the field \textit{.number}.\\

When defining the rigid boundary user only has to define the field \textit{.points}. Orientation of each segment has to be respected by the user so that the normal vectors are orientated towards the body of interest. Other two fields are constructed in the function $\textbf{buildSegmentsData}$. Individual segments are independent from each other and do not have to be connected. It is recommended for individual segments to be longer than the size of mesh elements.


\subsubsection{propContact}

Is a struct that contains the information about the possible contact nodes defined by the user in GiD. It consists out of four fields. Field \textit{.nodeIDs} is a vector that contains global numbering of nodes. Size of that vector is stored in field \textit{.numberOfNodes}. Both fields are constructed during the parsing from GiD input file. Maximum number of solver iterations is stored in the field \textit{.maxIter}. Field \textit{.gap} contains perpendicular distances from each segment to each contact node and it is constructed during calculation time. It is a MxN matrix where M is the number of contact nodes and N is the number of segments. Each column is linked to one segment.\\

User must define the possible contact nodes in GiD. In case of large applied forces, specifying the whole body as a boundary is usually a safe bet since large displacements and deformations in the first step of solver iteration might cause the contact nodes to move far away from the rigid boundary and in turn violating the linear gap function.


\subsubsection{lagrange}

Is a struct containing the information about Lagrange Multipliers. It consists out of two fields. Field \textit{.active\_nodes} contains the global numbering of the mesh nodes where Lagrange Multipliers apply. So only the active contact nodes. While field \textit{.multipliers} stores the values of Lagrange Multipliers of that nodes. This enables us to visualize the contact nodes and see the results.



\subsection{Function description}

\subsubsection{buildSegmentsData}

Is a function that expands a data structure $\textbf{segments}$ by the field \textit{.normals}. Normal vectors are perpendicular to the segment and normalized to have an unit length. Segment that starts in point $\mathbf{A}$ and ends in point $\mathbf{B}$ has its normal pointing in the counterclockwise direction (Figure~\ref{im:gap_function}).

\subsubsection{computeGapFunction}

Is a function that expands the data structure $\textbf{propContact}$ by the field \textit{.gap}. Gap function in our case is nothing more than a perpendicular distance from each node to each segment. Gap is shown on Figure~\ref{im:gap_function} and is calculated in the following way. Point $\mathbf{P}$ represents a node in undeformed configuration, while point $\mathbf{R}$ is the position of that node after applied displacement $\mathbf{u}$ and can be represented as follows,

\begin{equation}
	\mathbf{R} = \mathbf{P} + \mathbf{u} \:.
	\label{eq:point_after_displacement}
\end{equation}

Initial gap function is only calculated for undeformed configuration at $\mathbf{u}$ = 0, therefore $\mathbf{R}$ = $\mathbf{P}$ and $\mathbf{g}$ = $\mathbf{g_0}$. Point $\mathbf{R}^*$ is the projection of the point $\mathbf{R}$ on the segment $\mathbf{AB}$ and can be represented by a linear combination of points $\mathbf{A}$ and $\mathbf{B}$ by parameter $\alpha$.

\begin{equation}
	\mathbf{R}^\ast = (1-\alpha)\mathbf{A} + \alpha\mathbf{B} \:.
	\label{eq:projection_point_R}
\end{equation}

As vectors $\mathbf{AB}$ and $\mathbf{R}^*\mathbf{R}$ are perpendicular, their dot product must be equal to zero,

\begin{equation}
	(\mathbf{B}-\mathbf{A})\cdot(\mathbf{R}-\mathbf{R}^*) = 0 \:.
	\label{eq:dot_product_equality}
\end{equation}

If we substitute Eq.~\eqref{eq:projection_point_R} into Eq.~\eqref{eq:dot_product_equality} we get a closed form for parametric distance $\alpha$ along the segment $\mathbf{AB}$,

\begin{equation}
	\alpha = \frac{(\mathbf{A}-\mathbf{B})\cdot(\mathbf{R}-\mathbf{A})}{(\mathbf{A}-\mathbf{B})\cdot(\mathbf{B}-\mathbf{A})}  \:,
	\label{eq:parameter_alpha}
\end{equation}

\begin{equation}
	\mathbf{g} = \mathbf{n}\cdot(\mathbf{R}-\mathbf{R}^*)  \:.
	\label{eq:gap}
\end{equation}

Now we can easily compute point $\mathbf{R}^*$. Gap is then the dot product between normal and vector $\mathbf{R}^*\mathbf{R}$ in Eq.~\eqref{eq:gap} In case the node is penetrating the distance is negative, otherwise it is positive.

\begin{figure}[ht]
	\centering
	\footnotesize
    \def\svgwidth{0.85\textwidth}\import{./figures/}{gap_function.pdf_tex}
	\caption{Calculation of the gap function (Euclidean distance).}
	\label{im:gap_function}
\end{figure}

\subsubsection{buildConstraintMatrix}

Is a function that builds the constraint (Lagrange Multipliers) matrix $\mathbf{C}$ in Eq.~\eqref{eq:lagrange_multipliers_matrix} to be appended to the tangent stiffness matrix $\mathbf{K}$ in Eq.~\eqref{eq:tangent_stiffness_matrix}. The constraint matrix is built with dimensions MxN, where M is the number of DOFs and N is the number of active Lagrange Multipliers. The matrix is filled with the normal vectors of the segments. \\

In case that the function is used in Algorithm~\ref{alg:contact_algorithm_1}, the $\mathbf{C}$ matrix is constructed only once at the beginning. Number of active Lagrange Multipliers is unknown and the dimension N is replaced by the number of segments multiplied by the number of contact nodes.

\subsubsection{detectInactiveNodes}

Is a function used in Algorithm~\ref{alg:contact_algorithm_1} that detects inactive degrees of freedom in each step of iteration. Inactive DOFs are the ones that are non-penetrating and have non-compressive Lagrange Multipliers. To check if a node is non-penetrating, we have to evaluate its gap function to each segment after applied displacement $\mathbf{u \ne}$ 0. Node $\mathbf{R}$ must not lie within the gray area marked on the Figure~\ref{im:non_penetration}. Calculation is the same as in $\textbf{computeGapFunction}$, but now three extra conditions are evaluated,

\begin{equation}
	g > 0  \:,
	\label{eq:n_penetration}
\end{equation}

\begin{subequations}
	\begin{alignat}{1}
		\alpha < 0  \:, \label{eq:outside_boundary_1}\\
		\alpha \geq 1  \:.\label{eq:outside_boundary_2}
	\end{alignat}
	\label{eq:outside_boundary}
\end{subequations}

In addition to that, the node must have a non-compressive Lagrange Multiplier which is checked by Eq.~\eqref{eq:negative_lagrange}. If any of aforementioned conditions holds, the node is inactive.

\begin{equation}
	\lambda \leq 0 \:.
	\label{eq:negative_lagrange}
\end{equation}

\begin{figure}[ht]
	\centering
	\footnotesize
    \def\svgwidth{0.85\textwidth}\import{./figures/}{non_penetration.pdf_tex}
	\caption{Node penetration area.}
	\label{im:non_penetration}
\end{figure}

\subsubsection{detectActiveNodes}

Is a function used in Algorithm~\ref{alg:contact_algorithm_2} that detects active degrees of freedom in each step of iteration. The function is almost the same as $\textbf{detectInactiveNodes}$ with the only difference being that the conditions in Eq.~\eqref{eq:negative_lagrange} and Eq.~\eqref{eq:outside_boundary} are now reversed and Lagrange Multipliers are not checked. Node must penetrate the rigid boundary therefore all of the following conditions must hold,

\begin{equation}
	g < 0  \:,
	\label{eq:outside_penetration}
\end{equation}

\begin{subequations}
	\begin{alignat}{1}
		\alpha > 0  \:, \label{eq:inside_boundary_1}\\
		\alpha \leq 1  \:.\label{eq:inside_boundary_2}
	\end{alignat}
	\label{eq:inside_boundary}
\end{subequations}


\subsection{Equation systems}

\subsubsection{Expanded system of equations}

Correspond to discrete system of equations in terms of a Newton-Raphson formulation in Eq.~\eqref{eq:system_discrete_form_lagrange_multipliers}. If used in Algorithm~\ref{alg:contact_algorithm_1} the expanded system of equations is build only once at the beginning with full degrees of freedom of the system, as we would assume that all contact nodes can come with contact to any segment. Which nodes come into contact is of course not known in advance and it is computed during iterations. If used in Algorithm~\ref{alg:contact_algorithm_2} the system is only build for the active nodes during each iteration step. \\

Size of the expanded system of equations is know in advance and it is build with dimensions depicted in Figure~\ref{im:expanded_system}.

\begin{itemize}

	\item[i.] $\mathbf{K_{exp}}$ is an expanded global stiffness matrix. It consists of tangent stiffness matrix $\mathbf{K}$ and constraint (Lagrange Multiplier) matrix $\mathbf{C}$.
	
	\item[ii.] $\mathbf{u_{exp}}$ is an expanded displacement vector. It contains displacements $\mathbf{u}$ for each DOF and Lagrange Multipliers $\lambda$ for each node to each segment.
	
	\item[iii.] $\mathbf{F_{exp}}$ is an expanded force vector. It contains applied forces for each DOF and the initial gap functions $g_0$ from each node to each segment.
	
	\item[iv.] Algorithm~\ref{alg:contact_algorithm_1}: $\mathbf{NUM}$ = number of segments $\mathbf{\cdot}$ number of contact nodes
	
	\item[v.] Algorithm~\ref{alg:contact_algorithm_2}: $\mathbf{NUM}$ = number of active nodes (Lagrange Multipliers)

\end{itemize}

\begin{figure}[ht]
	\centering
	\footnotesize
    \def\svgwidth{0.8\textwidth}\import{./figures/}{equation_system.pdf_tex}
	\caption{Expanded system of equations.}
	\label{im:expanded_system}
\end{figure}

\subsubsection{Reduced system of equations}

After finding the inactive nodes in each iteration of Algorithm~\ref{alg:contact_algorithm_1} we can merge them together with homDBC and remove corresponding entries in expanded system. We get the reduced system of equations that we can be solved by, 

\begin{equation}
	\mathbf{u_{red}} = \mathbf{K_{red}}^{-1}  \mathbf{F_{red}} \:,
	\label{eq:reduced_system}
\end{equation}

to obtain displacements. From reduced displacement vector the full (expanded) displacement vector is then build. If we on the other hand use Algorithm~\ref{alg:contact_algorithm_2}, then we simply solve the expanded system directly and relax it until only valid Lagrange Multipliers remain.

\begin{equation}
	\mathbf{u_{exp}} = \mathbf{K_{exp}}^{-1}  \mathbf{F_{exp}} \:.
	\label{eq:expanded_system}
\end{equation}



\subsubsection{Convergence conditions}

There are two main convergence conditions that need to be meet before exiting either of aforementioned algorithms. Set of inactive nodes must stay the same as in previous iteration and all Lagrange Multipliers have to be valid. In addition, we specify the maximum number of iterations in case our solution does not converge.

% \bibliographystyle{elsarticle-num-names}
\bibliographystyle{alpha}
\bibliography{literature}
\nocite{*}

\end{document}